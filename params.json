{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"ServiceInterceptor","body":"ServiceInterceptor\r\n==================\r\n\r\n###Overview###\r\n\r\nThe ServiceInterceptor is a generic, extendable, and derivable attribute that \r\ncan be placed on any WCF service or method to gain access to the many \r\nhooks/interception points that WCF provides.\r\n\r\nIn a nutshell, it is a wrapper around the various integration points built\r\ninto WCF ( The .NET Windows Communication Foundation framework for building \r\nservice-oriented applications ).\r\n\r\nIts primary usage is to be able to easily decorate a web service class with\r\nthe ServiceInterceptor attribute and inherit from the IServiceInterceptor\r\ninterface to gain access to the `BeforeCall()` and `AfterCall()` interception\r\nmethods but there are many other ways to use this handy attribute.\r\n\r\n###Usage###\r\n\r\n####IServiceInterceptor####\r\n\r\nThe following example uses the ServiceInterceptor attribute in conjunction with\r\nthe IServiceInterceptor interface to gain access to the before and after method\r\ncall hooks.\r\n\r\n```csharp\r\n[ServiceContract]\r\npublic interface IHelloWorldService\r\n{\r\n\t[OperationContract]\r\n\tstring SayHello( string name );\r\n}\r\n\r\n[ServiceInterceptor]\r\npublic class HelloWorldService : IHelloWorldService, IServiceInterceptor\r\n{\r\n\tpublic string SayHello( string name )\r\n\t{\r\n\t\treturn string.Format( \"Hello, {0}\", name );\r\n\t}\r\n\r\n\t#region Implementation of IServiceInterceptor\r\n\r\n\t/// <summary>\r\n\t/// Called after the request has been received and deserialized in a WCF message object,\r\n\t/// but before the operation method has been invoked.\r\n\t/// </summary>\r\n\t/// <param name=\"operationName\">The name of the operation.</param>\r\n\t/// <param name=\"inputs\">The objects passed to the method by the client.</param>\r\n\t/// <returns>\r\n\t/// The correlation state that is returned as the correlationState parameter in AfterCall. \r\n\t/// Return null if you do not intend to use correlation state.\r\n\t/// </returns>\r\n\tpublic object BeforeCall( string operationName, object[] inputs )\r\n\t{\r\n\t\t// Do whatever you want before the service method has been called.\r\n\t\t\r\n\t\t// Examples: Log method calls, perform validation on the inputs, perform basic\r\n\t\t//           authentication/authorization, initialize a unit-of-work, etc.\r\n\t\t\r\n\t\t// You could throw a FaultException to abort the call to the service method\r\n\t\t// or you could modify the inputs to the service method, etc.\r\n\t\t\r\n\t\t// You can return an object which will be passed as the correlationState parameter\r\n\t\t// to the AfterCall() method or simply return null.\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/// <summary>\r\n\t/// Called after the operation has been invoked, but before the response is to be serialized.\r\n\t/// </summary>\r\n\t/// <param name=\"operationName\">The name of the invoked operation.</param>\r\n\t/// <param name=\"outputs\">Any output objects.</param>\r\n\t/// <param name=\"returnValue\">The return value of the operation.</param>\r\n\t/// <param name=\"correlationState\">Any correlation state returned from the BeforeCall method, or null.</param>\r\n\tpublic void AfterCall( string operationName, object[] outputs, object returnValue, object correlationState )\r\n\t{\r\n\t\t// Do whatever you want after the service method has been called.\r\n\t}\r\n\r\n\t#endregion Implementation of IServiceInterceptor\r\n}\r\n```\r\n\r\n####Creating Custom Attributes####\r\n\r\nThe following example demonstrates how easy it is to create a custom attribute\r\nby deriving from the ServiceInterceptorAttribute and overriding two of its methods\r\nin order to implement a basic logging attribute that can be placed on the service\r\nitself or on any method that needs the desired behavior.\r\n\r\n```csharp\r\n\r\n[ServiceContract]\r\npublic interface IHelloWorldService\r\n{\r\n\t[OperationContract]\r\n\tstring SayHello( string name );\r\n}\r\n\r\n[LogCallsToDebugger]\r\npublic class HelloWorldService : IHelloWorldService\r\n{\r\n\tpublic string SayHello( string name )\r\n\t{\r\n\t\treturn string.Format( \"Hello, {0}\", name );\r\n\t}\r\n}\r\n\r\n/// <summary>\r\n/// Example of a custom interceptor that logs calls to the debug trace listeners.\r\n/// </summary>\r\npublic class LogCallsToDebugger : ServiceInterceptorAttribute\r\n{\r\n\tprivate Type _serviceType;\r\n\r\n\tpublic override void ApplyDispatchBehavior( ServiceDescription serviceDescription, ServiceHostBase serviceHostBase )\r\n\t{\r\n\t\t_serviceType = serviceDescription.ServiceType;\r\n\r\n\t\tbase.ApplyDispatchBehavior( serviceDescription, serviceHostBase );\r\n\t}\r\n\r\n\tpublic override object BeforeCall( string operationName, object[] inputs )\r\n\t{\r\n\t\tstring message = string.Format( \"{0}.{1} was called.\", _serviceType.Name, operationName );\r\n\r\n\t\tDebug.WriteLine( message );\r\n\r\n\t\treturn base.BeforeCall( operationName, inputs );\r\n\t}\r\n}\r\n\r\n```\r\n\r\n\r\nPlease see the test project for more usage examples.\r\n\r\n###License###\r\n\r\nServiceInterceptor v1.0.0.0 ( https://github.com/randyburden/ServiceInterceptor )\r\n\r\nMIT License:\r\n\r\nCopyright (c) 2013, Randy Burden ( http://randyburden.com )\r\nAll rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and \r\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including \r\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \r\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the \r\nfollowing conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial \r\nportions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT \r\nLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN \r\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ","tagline":"A WCF service interceptor that provides easy access to the many hooks/interception points that WCF provides.","google":""}